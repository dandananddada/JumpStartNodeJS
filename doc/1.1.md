	对于存在的事物，你会问为什么？
	对于不存在的事物，我会问为什么不？
																			——萧伯纳

####为什么用Node.js

如果一张图片上能拼写出一千个单词，那么一千张图片能拼写出多少个单词呢？如果是无穷无尽这样的图片呢？

我先通过一个[拼字游戏](http://www.wordsquared.com/)<sup>[[1]](说明)</sup>（如图1.1）来介绍Node.js。这是一个实时在线的没有结束的拼字游戏，这个游戏使用的技术和本书要讲解的技术是一致的。当我第一次看到这个游戏的时候就有了想去了解其技术实现的冲动，所以希望你也能试玩下这个游戏。令人难以置信的一点是，这个游戏是作为[Node Knockout大赛](http://www.nodeknockout.com/)的参赛作品，其制作用时只有48个小时。

Joynet的工程副总裁坎特里尔·布莱恩（Bryan Cantrill）曾经说过当你用Node.js去做一些东西的时候，你可能会有这样的感觉：真的是这样的么？是不是需要更加复杂一些。我在跟你分享这本书的内容的时候也是这样的情绪。通过对这本书的学习你会发现用Node.js去做些东西是很有乐趣的。

Node.js是一个服务端的JavaScript平台，由一个极简的核心库和丰富的生态系统组成。它基于谷歌的V8内核之上运行，因为谷歌出色的工程师使V8这个Javascript引擎速度非常的快。同时JavaScript这门语言在客户端也十分流行，但是它作为Node.js的标准语言其实是出于工程方面考虑的。具体细节会在本章的后续介绍中详细说明。


Node.js官方的介绍是这样的

	Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，他可以很方便的创建快速、灵活的网络应用。
	Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。
	Node.js 在分布式部署的数据密集型实时应用方面表现完美。

对于新手来说这似乎难以理解，这只是简单总结了Node.js一些核心的优点，仍然还有很多细节需要进一步说明。

通常当人们听说用Javascript作为目标语言时都会感到震惊，那是因为在程序员的社区中普遍认为Javascript不像C、C++或者Java那样是一个地道的编程语言。JavaScript最早是作为浏览器的解释型语言出现的，其名字中的`Java`实际上是为了能有个好兆头而取自当时愈发火热的Java语言。

JavaScript从最初很低的起点开始发展到现在已经被所有主流浏览器支持，同时也包括移动端的浏览器。它不仅是一个流行的语言，同时因为它在市面上有着大量的工具和库可供使用，使它也成为一个真正强大的工程工具。JavaScript在服务端也提供了像其他技术能做到的诸如持续集成、部署、关系型数据库链接、面向业务架构等支持。

在与谷歌V8引擎的结合下，现在Node.js的速度已经相当快。事实上它比Ruby、Python等其他脚本语言速度要快上几倍。在[benchmark](http://benchmarksgame.alioth.debian.org/)提供的测试结果中，同等程度的代码其各项测试平均水平，JavaScript V8引擎的速度是Python3的13倍，是Ruby的8倍。这个结果对于一个动态语言来说是难以置信的，不小一部分是因为V8内核的优化，像编译成机器语言预执行。

	Benchmarking（衡量标准）

	Benchmarking是一个复杂的话题，同时这些数据也是不能让人完全信服的。这里用Benchmarking提供的数据只是为了消除人们对JavaScript语言本身很慢的误解。

官方介绍中有提到事件驱动和非阻塞I/O，传统的程序都是通过同步方式工作的，当一句代码在执行时，系统会等待其返回结果并作出处理，之后才会执行后续的代码。因此有时会出现很长的等待时间，比如在网络环境下读写数据库的操作。

像Java和C#这种语言可以通过开辟新线程的方式来解决这种问题。一个线程可以看作是一个用来处理任务的轻量级的进程。在多线程编程中如果存在多个线程同时请求同一个资源，这将是一件很难处理的事。举个例子简单说明这种业务场景：比如有一个计数器，现在两个线程同时操作这个计数器，一个线程增加计数器数字，而另一个则相反减少计数器数字。

JavaScript通过另一种方式解决了这种问题，那就是只允许有一个线程。当进行耗时的I/O操作时，比如读数据库，程序不会等待，相应的它会立刻执行这行代码后续的代码。当I/O操作返回结果时，它会触发一个回调函数来处理返回结果。这种操作方式看起来是不太现实的，不用担心在这本书会在后续相信说明，因为这种操作方式我们会反复用到。Node.js的简洁、快速、事件驱动编程模型等特性很适合当代这种异步的Web应用程序。
	
####优点和缺点

Node.js不是万能的，它也存在一系列的问题，计算机程序可以被大致分为两类：CPU密集型和I/O密集型，对计算机密集型问题的处理能力取决于计算机时钟周期的数量，[质数计算]() <sup>[[2]]()</sup> 就是一个例子。Node.js本身的设计不是为了解决CPU密集型的问题。在Node.js正式发布之前，Ryan Dahl曾提出：

	现在有一个非常苛刻的需求，任何一个计算的请求都必须在5毫秒内返回，如果你超过了这个时间限制。那么这个请求就会被中断。如果你提及了一个相当蠢的而且还说阻塞的JavaScript服务端代码，用它来计算前 10000 个质数的时候就会被中断。

	我们需要一个不允许开发者去写出很蠢的代码这样一个开发环境，Ruby、Python、C++、PHP这些语言对于做web开发的人来说都过于自由和灵活了。


对于I/O密集型问题的处理能力取决于I/O的吞吐量，比如硬盘、内存和网络带宽、甚至数据缓存都可以产生影响。许多问题都是I/O密集型的，比如说[C10K]()<sup>[[3]]()</sup>，在这一方面Node.js是十分合适的，它能作为一个web服务端能处理十万或者更多个客户端同时链接。一些其他的技术平台是没有这样的容纳能力的，它们需要各样的补或者变通的方法来处理这种问题。Node.js能够胜任这种业务是因为它为有专门为并发场景而设计的异步非阻塞机制。

希望通过我的说明，你能对Node.js有进一步了解的兴趣，是时候开始进入正题了。

	这本书将要构建一个实时的股票交易引擎，它将在浏览器端实时更新价格。出于好奇，你可能会问“是不是应该用C来构建一个股票市场的交易引擎来提升运算速度？” 是的，如果我们真的要构建一个应用于实际的交易引擎，我们肯定会用C

	这本书的主要目的是说明讲解一些技术内容而不是构建一个投入使用的项目。对于股票交易这种特殊的实时应用，对软件和硬件的要求是很特殊的，因为它要满足微秒级的计数。除此之外也有很多不需要微秒级精准的应用不如Twitter、Facebook、eBay。这就是Node.js所擅长的，你将会通过这本书了解如何去构建这些应用。




















